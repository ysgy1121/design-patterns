# 템플릿 메소드 패턴과 전략 패턴의 비교

## 공통점 : 행위(알고리즘) 정의 및 분리 💡
두 패턴 모두 행위(Behavioral) 디자인 패턴으로, 다음과 같은 목적을 공유합니다.

- 알고리즘 정의 및 캡슐화: 문제 해결을 위한 알고리즘이나 행위 로직을 정의합니다.
- 변하는 부분과 변하지 않는 부분의 분리: 고정된 로직(뼈대, 컨텍스트)과 자주 변하는 로직(알고리즘의 구현, 단계별 세부사항)을 분리하여 개방-폐쇄 원칙(OCP - Open/Closed Principle)을 준수하고 코드 중복을 줄이는 데 사용됩니다.
- 유연성과 확장성 확보: 코드를 변경하지 않고 새로운 알고리즘이나 단계별 구현을 쉽게 추가하거나 교체할 수 있게 합니다.<br><br>

# 차이점 : 구현 방식과 목적 🛠️
두 패턴의 주요 차이점은 구현 방식과 변화의 범위에 있습니다.

| 비교 항목 | 템플릿 메소드 패턴 (Template Method Pattern) | 전략 패턴 (Strategy Pattern) |
|:---:|:---|:---|
| 핵심 기법 | 상속(Inheritance) | 구성(Composition) / 위임(Delegation) |
| 변화의 범위 | 알고리즘의 구조(뼈대)는 고정, 특정 단계만 변경 | 알고리즘 전체를 교체 |
| 주요 의존성 | 서브클래스가 슈퍼클래스에 의존 (강한 결합) | 컨텍스트가 인터페이스/추상 클래스인 전략에 의존 (느슨한 결합) |
| 유연성 | 런타임 변경은 어려우며, 컴파일 타임에 서브클래스를 통해 정의 | 전략을 외부에서 주입받아 런타임에 동적으로 변경 가능 |
| 주 사용 목적 | 알고리즘의 단계를 정의하고, 순서와 구조를 통제하며 특정 단계의 구현을 서브클래스에 위임하는 것이 목적 | 알고리즘 자체를 숨기고 쉽게 교체하는 것이 목적 (e.g., 다양한 결제 방식, 정렬 알고리즘 선택) |


### 1. 템플릿 메소드 패턴 (Template Method Pattern)
알고리즘의 뼈대(스켈레톤) 정의: 슈퍼클래스(추상 클래스)에서 알고리즘의 전체 구조와 순서를 정의하는 템플릿 메소드를 구현하고, 가변적인 단계는 추상 메소드나 훅(Hook) 메소드로 정의하여 서브클래스에서 구체화하도록 합니다.

상속 기반의 확장: 서브클래스가 슈퍼클래스를 상속받아 변하는 부분을 오버라이딩하여 구현합니다. 알고리즘의 구조는 변경할 수 없으며, 특정 단계만 다르게 구현할 수 있습니다.

### 2. 전략 패턴 (Strategy Pattern)
알고리즘의 캡슐화 및 주입: 알고리즘(전략)을 인터페이스로 추상화하고, 각각의 구체적인 전략을 별도의 클래스로 캡슐화합니다.

구성(Composition) 기반의 유연성: 컨텍스트 클래스는 전략 인터페이스를 필드로 구성하고, 클라이언트로부터 구체적인 전략 객체를 주입받아 사용합니다.

높은 유연성: 알고리즘 전체를 런타임에 동적으로 쉽게 교체할 수 있어, 의존성이 낮고 변화에 유연합니다.