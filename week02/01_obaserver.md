# 옵저버 패턴 (Observer Pattern)
옵저버 패턴은 한 객체의 상태 변화를 여러 객체가 자동으로 인지하고 반응하도록 하는 디자인 패턴입니다.

## 💡 핵심 원칙 및 특징
느슨한 결합: 주체와 옵저버가 직접적인 참조 대신 통신하기 때문에, 서로의 코드 변경 없이 새로운 옵저버를 추가하거나 제거할 수 있어 유지보수와 확장이 용이합니다.

객체 의존성 감소: 주체는 자신이 의존하는 모든 옵저버에 대해 알 필요가 없으며, 옵저버들은 주체에 대해 알아야 할 필요가 없습니다. 

## ☕️ 구성 요소

### 주체(Subject/Publisher):
상태 변화가 일어나는 객체입니다. 자신의 상태가 변하면 등록된 모든 옵저버들에게 알림(notify)을 보냅니다.

### 옵저버(Observer/Subscriber):
주체의 상태 변화를 관찰하는 객체입니다. 주체에 등록(subscribe)하여, 상태 변경 알림을 받으면 자신만의 방식으로 반응(update)합니다. 

## 📚 장점 및 디자인 원칙
느슨한 결합(Loose Coupling): 주제 객체는 옵저버 객체가 특정 인터페이스만 구현하고 있다는 사실만 알면 됩니다. 서로의 구체적인 구현을 알 필요가 없으므로, 한쪽의 변경이 다른 쪽에 미치는 영향을 최소화합니다. 
객체 의존성 감소: 주제와 옵저버 객체가 독립적으로 재사용될 수 있습니다. 새로운 옵저버를 추가해도 주제를 수정할 필요가 없고, 주제나 옵저버가 변경되어도 서로에게 영향을 주지 않습니다. 

## 💻 예제 코드: 점심시간, 저녁시간 알림
TimerSubject는 매 시간마다 등록된 observers에게 알림을 줍니다. DinnerTimerObserver는 시간을 확인하고 싶을때 TimerSubject에 본인을 등록하고 update에 따라 저녁시간인지 확인할 수 있습니다. 더이상 시간을 확인하지 않아도 될때는 등록을 취소하면 됩니다.


## 🤔 심화 질문 01: 옵저버 패턴과 Pub/Sub 패턴의 비교
- Pub/Sub의 경우 메세지큐나 EventBus와 같은 중재자를 통해 간접적으로 통신합니다.
- stream은 옵저버 패턴에 "시간"과 "함수형 처리 능력"을 더해서, 움직이는 데이터를 다루기 편하게 만든 개념입니다.


## 🤔 심화 질문 02: 옵저버 패턴의 단점 및 제약 사항
### 처리 순서의 불확실성 
Observer가 알림을 받는 순서는 일반적으로 등록된 순서에 의존하지만, 패턴 자체는 특정 순서를 보장하지 않습니다. 만약 여러 Observer가 서로 의존하거나, 특정 순서대로 작업을 완료해야 하는 로직이 있다면 예상치 못한 버그나 **경쟁 조건(Race Condition)**이 발생할 수 있습니다.
우선순위 부여: Observer 등록 시 **우선순위(Priority)**를 지정하고, Subject가 알림을 보낼 때 이 우선순위에 따라 정렬하여 호출합니다.
책임 사슬 패턴(Chain of Responsibility) 연계: 순서가 중요한 경우, 알림을 받은 첫 번째 Observer가 다음 Observer를 명시적으로 호출하는 방식으로 순서를 제어합니다.
Pub/Sub 도입: 순서 보장이 필수적이며 비동기 처리가 필요할 경우, 메시지 큐(Message Queue)를 중재자로 사용하여 메시지의 순차적 처리를 보장할 수 있습니다.

### 알 필요 없는 변경 사항에 대한 확인
Subject의 어떤 상태가 변하든, 등록된 모든 Observer에게 알림(update())이 전달됩니다. 따라서, Observer 입장에서는 자신과 무관한 상태 변화에 대해서도 알림을 받아야 하고, 알림을 받은 후 '나와 관련된 변경인지'를 확인하는 불필요한 로직을 수행해야 합니다. 이는 성능 저하와 불필요한 계산 비용을 야기합니다.
세부 이벤트/토픽 도입: Subject가 상태 변화를 알릴 때 이벤트의 타입(Type) 또는 **변경된 데이터의 키(Key)**를 함께 전달하도록 합니다. Observer는 이 타입을 확인하여 자신과 관련된 알림만 처리합니다.
Pull 방식 도입: Subject는 상태 변화가 발생했음을 알리기만 하고, 실제 변경된 데이터는 Observer가 필요할 때 Subject에게 요청(Pull)하여 가져가도록 설계합니다. 이 경우, Observer는 알림을 받은 후 필요한 데이터만 선별적으로 가져오므로 불필요한 데이터 확인을 줄일 수 있습니다.