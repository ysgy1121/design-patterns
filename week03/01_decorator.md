# 데코레이터 패턴 (Decorator Pattern)

데코레이터 패턴이란 주어진 상황 및 용도에 따라 어떤 객체에 책임을 덧붙이는 패턴으로, 기능 확장이 필요할 때 **상속(Subclassing) 대신 구성(Composition)**을 사용하여 기능을 동적으로 추가하거나 제거할 수 있습니다.

## 💡 핵심 원칙 및 특징

**기능의 동적 확장:** 객체의 기능을 런타임에 유연하게 조합하고 확장할 수 있습니다.
**상속 문제 회피:** 상속을 사용하면 기능의 조합이 기하급수적으로 늘어나 많은 서브클래스가 생기는 문제를 해결합니다 (클래스 폭발 문제).
**투명성:** 데코레이터와 핵심 컴포넌트가 동일한 인터페이스를 공유하므로, 클라이언트는 자신이 데코레이터로 감싸진 객체를 다루는지 알 필요가 없습니다.

## ☕️ 구성 요소

| 구성 요소 | 역할 |
| :--- | :--- |
| **컴포넌트 (Component)** | 데코레이터와 구체 컴포넌트가 구현할 **기본 기능**을 정의하는 인터페이스(또는 추상 클래스). |
| **구체 컴포넌트 (Concrete Component)** | 추가될 기능 없이, **핵심 기본 기능**을 구현하는 클래스. |
| **데코레이터 (Decorator)** | 컴포넌트 인터페이스를 구현하며, 내부적으로 **래핑할 컴포넌트**에 대한 참조(필드)를 가지는 추상 클래스. |
| **구체 데코레이터 (Concrete Decorator)** | 데코레이터를 상속받아 **특정 부가 기능**을 추가하는 클래스. 래핑된 객체의 메서드를 호출하기 전이나 후에 자신의 기능을 실행합니다. |

## 📚 장점 및 디자인 원칙

**개방-폐쇄 원칙(OCP) 준수:** 기존의 구체 컴포넌트 클래스를 **수정하지 않고** (`폐쇄`) 새로운 데코레이터 클래스를 추가하여 기능을 **확장** (`개방`)할 수 있습니다.
**단일 책임 원칙(SRP) 준수:** 각 데코레이터는 하나의 추가적인 책임(예: 로깅, 압축, 테두리 추가)만 가지므로 코드가 단순하고 유지보수가 쉽습니다.
**유연한 조합:** 여러 데코레이터를 중첩하여 사용함으로써 복잡한 기능 조합을 쉽게 만들 수 있습니다.

## 💻 예제 코드: 커피에 옵션 추가

`Beverage` 인터페이스가 기본 기능을 정의하고, `Decaf`가 기본 구현을 담당합니다. `Milk`와 `Whip`는 `CondimentDecorator`를 상속받아 `Decaf` 객체를 감싸서 (래핑하여) 가격이나 설명을 동적으로 덧붙입니다.

```dart
var beverage = Milk(Mocha(Decaf()));
print('${beverage.getDescription()} ${beverage.cost()}');
```

-----

## 🤔 심화 질문 01: 데코레이터 패턴과 프록시 패턴의 비교

| 특징 | 데코레이터 패턴 (Decorator) | 프록시 패턴 (Proxy) |
| :--- | :--- | :--- |
| **목적** | **기능 추가 및 확장** (동적으로 책임 덧붙이기) | **접근 제어 및 관리** (원격, 보안, 지연 초기화 등) |
| **구현** | 보통 여러 개의 데코레이터를 **중첩**하여 사용함. | 주로 하나의 프록시가 주체에 대한 접근을 **대리**함. |

## 🤔 심화 질문 02: 데코레이터 패턴의 단점 및 제약 사항

  * **다수 객체 생성:** 기능 하나를 추가할 때마다 데코레이터 객체를 생성해야 하므로, 객체의 수가 불필요하게 늘어나 시스템이 복잡해질 수 있습니다.
  * **복잡한 초기화:** 데코레이터를 여러 겹 중첩할 경우, 클라이언트 코드에서 객체를 생성하고 초기화하는 과정이 복잡해지고 가독성이 떨어질 수 있습니다.
  * **동일성 문제:** 래핑된 객체와 데코레이터는 동일한 인터페이스를 가지지만, 클래스 타입은 다르기 때문에 객체의 동일성(`==` 연산 또는 `is` 체크)을 확인하는 로직에서 문제가 발생할 수 있습니다.