# 컴포지트 패턴 (Composite Pattern)

컴포지트 패턴이란 객체들의 **부분-전체(Part-Whole) 계층**을 표현하기 위해 객체들을 트리 구조로 묶는 패턴입니다. 클라이언트가 **개별 객체(Leaf)**와 **복합 객체(Composite)**를 동일하게 다룰 수 있도록 합니다.

## 💡 핵심 원칙 및 특징

**균일성(Uniformity):** 개별 객체와 복합 객체를 구분 없이 처리할 수 있게 합니다.
**재귀적 구조:** 복합 객체는 다시 복합 객체나 개별 객체를 포함할 수 있어 계층적인 트리 구조를 표현합니다.
**단순화:** 클라이언트 코드가 복합 객체의 구조를 몰라도 모든 객체에 대해 동일한 작업을 수행할 수 있도록 단순화합니다.

## ☕️ 구성 요소

| 구성 요소 | 역할 |
| :--- | :--- |
| **컴포넌트 (Component)** | 개별 객체와 복합 객체 모두가 구현해야 할 **공통 인터페이스**를 정의합니다. (예: `Operation()` 메서드) |
| **개별 객체 (Leaf)** | 트리 구조에서 더 이상 하위 요소를 가질 수 없는 **개별적**인 객체입니다. 컴포넌트의 기본 기능을 구현합니다. |
| **복합 객체 (Composite)** | 하위 컴포넌트(Leaf 또는 다른 Composite)를 **포함**하는 객체입니다. 컴포넌트의 기능을 구현하며, 하위 요소 관리를 위한 메서드(예: `add()`, `remove()`)를 추가로 정의합니다. |

## 📚 장점 및 디자인 원칙

**클라이언트 단순성:** 클라이언트가 개별 객체와 복합 객체의 차이를 구분할 필요 없이 동일한 인터페이스를 통해 작업할 수 있어 코드가 단순해집니다.
**새로운 타입의 추가 용이성:** 새로운 개별 객체나 복합 객체를 추가하더라도 기존 클라이언트 코드를 변경할 필요가 거의 없습니다.
**계층 구조 표현:** 디렉토리-파일 구조, 조직도 등 자연스러운 트리 계층 구조를 효과적으로 모델링합니다.

## 💻 예제 코드: 파일 시스템 구조

`OrganizationComponent` 인터페이스가 기본 기능을 정의하고, `Employee`가 개별 객체(Leaf)를, `Department, Company`가 복합 객체(Composite)를 담당합니다. `Company`는 `Employee`이나 다른 `Department`를 포함할 수 있습니다.

```dart
var company = Company('A기업');
company.add(Employee('김사장', 'CEO'));

var hr = Department('인사');
hr.add(Employee('이인사', '인사 매니저'));
hr.add(Employee('김인사', '인사 스페셜리스트'));
company.add(hr);
```

-----

## 🤔 심화 질문 01: 컴포지트 패턴과 데코레이터 패턴의 비교

| 특징 | 컴포지트 패턴 (Composite) | 데코레이터 패턴 (Decorator) |
| :--- | :--- | :--- |
| **목적** | **계층 구조** 표현 및 개별/복합 객체 **균일 처리** | **기능 동적 확장** 및 책임 추가 |
| **핵심 관계** | **부분-전체(Part-Whole)** 계층. 복합 객체는 하위 객체들의 컬렉션(Collection)을 가짐. | **래핑(Wrapping)** 관계. 데코레이터는 **하나의** 핵심 객체에 대한 참조를 가짐. |
| **메서드** | 하위 요소 관리를 위한 메서드(`add`, `remove`)를 가짐. | 하위 요소 관리 메서드가 없으며, 핵심 객체의 기능에 부가 기능을 추가하는 데 집중. |

## 🤔 심화 질문 02: 컴포지트 패턴의 단점 및 제약 사항

  * **컴포넌트 인터페이스 비대화:** 개별 객체(Leaf)에게는 필요 없는 `add()`나 `remove()` 같은 복합 객체 관리 메서드까지도 `Component` 인터페이스에 포함해야 하므로, 인터페이스가 비대해질 수 있습니다 (안전성 vs. 투명성 트레이드오프).
  * **런타임 타입 확인:** 특정 작업이 개별 객체에서만 유효할 경우, 클라이언트가 런타임에 타입을 확인(`instanceof` 또는 `is`)해야 하는 상황이 발생할 수 있습니다.
  * **복잡한 구조:** 객체 구조가 너무 깊어지거나 복잡해지면 디버깅 및 관리가 어려워질 수 있습니다.